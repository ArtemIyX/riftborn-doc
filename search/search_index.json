{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Riftborn","text":""},{"location":"#project-structure-plugins","title":"Project Structure - Plugins","text":"<ul> <li>Ability System</li> <li>Actor Pool</li> <li>Advanced Asset</li> <li>Advanced Logger</li> <li>Advanced Movement</li> <li>Advanced Sessions</li> <li>Blueprint Compile</li> <li>Data Serializer</li> <li>Easy Settings</li> <li>Replicated Object</li> <li>Melee Master</li> <li>Menu Plugin</li> </ul>"},{"location":"plugins/ability-system/","title":"Ability System","text":""},{"location":"plugins/ability-system/#about-the-plugin","title":"About the plugin","text":"<p>Github Repository</p> <p>Author plugin written for Riftborn. It implements the \"attributes\" and \"effects\" system.</p> <ul> <li>Attributes are entities that store a float variable.</li> <li>Effects are entities that modify attributes.</li> </ul>"},{"location":"plugins/ability-system/#attributes","title":"Attributes","text":"<p>You can create your own attributes by inheriting from UAttribute.</p> ArmorAttribute.h<pre><code>UCLASS(Blueprintable, BlueprintType)\nclass HUM_API UArmorAttribute : public UAttribute\n{\n    GENERATED_BODY()\n\npublic:\n    UArmorAttribute(const FObjectInitializer&amp; InObjectInitializer = FObjectInitializer::Get());\n\npublic:\n    virtual FString GetDebugString_Implementation() const override;\n};\n</code></pre> <p>Info</p> <p>Be sure to overwrite the GetDebugString function so that other developers can understand which  attribute currently exists on the actor.</p> <p>There are some events that can be useful for tracking the status of Attribute: - OnMinValueChanged - OnMaxValueChanged - OnValueChanged - OnValueMinThresholdReached - OnValueMaxThresholdReached</p>"},{"location":"plugins/ability-system/#effects","title":"Effects","text":"<p>There are only 4 types of effect in the plugin:</p> <ul> <li>Effect</li> <li>PeriodicInstantEffect</li> <li>DurationEffect</li> <li>PeriodicEffect </li> </ul> <pre><code>classDiagram\n    UAdvancedReplicatedObject &lt;|-- UBasicAsEntity\n    UBasicAsEntity &lt;|-- UEffect\n    UEffect &lt;|-- UDurationEffect\n    UEffect &lt;|-- UPeriodicInstantEffect\n    UDurationEffect &lt;|-- UPeriodicEffect\n\n    class UAdvancedReplicatedObject {\n    }\n\n    class UBasicAsEntity {\n    }\n\n    class UEffect {\n        +OnAttributeListUpdated()\n        +OnAttributeAdded()\n        +OnAttributeRemoving()\n        +OnEffectListUpdated()\n        +OnEffectAdded()\n        +OnEffectRemoving()\n        +StartWork()\n        +OnWorkEnded()\n        +GetOwningComponent() UASComponent\n    }\n\n    class UDurationEffect {\n        +float Time\n    }\n\n    class UPeriodicInstantEffect {\n        +float Period\n    }\n\n    class UPeriodicEffect {\n        +float Period\n    }</code></pre>"},{"location":"plugins/ability-system/#effect","title":"Effect","text":"<p>UEffect is the base abstract class for all effects.</p> Effect.h<pre><code>class ABILITYSYSTEM_API UEffect : public UBasicAsEntity\n</code></pre> <p>Note</p> <p>It automatically receives notifications about changes to other effects and attributes.</p> <p>When an effect is added, it starts working. When an effect is removed, it finishes the job.</p> Effect.h<pre><code>UFUNCTION(BlueprintNativeEvent, Category=\"Effect|Main\")\nvoid StartWork();\n\nUFUNCTION(BlueprintNativeEvent, Category=\"Effect|Main\")\nvoid OnWorkEnded();\n</code></pre> <p>Effect life cycle</p> <p>You can call EndWork() to terminate the effect.</p> <p>This will call the EffectHasEnded(this) method of the effect owner (GetOwningComponent()), which will properly clear memory and remove the effect from the array by calling OnWorkEnded() and ConditionalBeginDestroy() on it</p>"},{"location":"plugins/ability-system/#periodicinstanteffect","title":"PeriodicInstantEffect","text":"<p>PeriodicInstantEffect starts a looped timer for an \"Tick\" action.</p> PeriodicInstantEffect.h<pre><code>class ABILITYSYSTEM_API UPeriodicInstantEffect : public UEffect\n</code></pre> <p>Note</p> <p>On StartWork() it calls RunPeriodicTimer(), on EndWork() it calls ClearPeriodicTimer()</p> PeriodicInstantEffect.cpp<pre><code>void UPeriodicInstantEffect::RunPeriodicTimer()\n{\n    FTimerManager&amp; manager = GetWorld()-&gt;GetTimerManager();\n    if (manager.IsTimerActive(PeriodicTimerHandle))\n        manager.ClearTimer(PeriodicTimerHandle);\n    manager.SetTimer(PeriodicTimerHandle, FTimerDelegate::CreateUObject(this, &amp;UPeriodicInstantEffect::PeriodTick),\n                     FMath::IsNearlyZero(Period) ? 0.1f : Period, true);\n}\n\nvoid UPeriodicInstantEffect::ClearPeriodicTimer()\n{\n    FTimerManager&amp; manager = GetWorld()-&gt;GetTimerManager();\n    if (manager.IsTimerActive(PeriodicTimerHandle))\n        manager.ClearTimer(PeriodicTimerHandle);\n}\n</code></pre> <p>You just need to override PeriodTick() in your class for looped actions.</p> PeriodicInstantEffect.h<pre><code>/**\n* @brief Called periodically\n*\n* The `PeriodTick` function is executed at regular intervals while the effect is active. It allows the developer\n* to define custom logic that should occur periodically, such as applying damage, healing, or other time-based effects.\n* This function is intended to be overridden in derived classes for specific behavior.\n*/\nUFUNCTION(BlueprintNativeEvent)\nvoid PeriodTick();\n</code></pre> <p>You can adjust the intervals of the effect in Blueprints by changing the \u2018Period\u2019 field.</p> PeriodicInstantEffect.h<pre><code>UPROPERTY(BlueprintReadWrite,\n    EditDefaultsOnly,\n    meta=(UIMin=\"0.0001\",\n        ClampMin=\"0.0001\"),\n    Category=\"PeriodicEffect\")\nfloat Period;\n</code></pre>"},{"location":"plugins/ability-system/#durationeffect","title":"DurationEffect","text":"<p>This effect activates a timer at the beginning of its work. When the timer expires, the effect automatically ends. Useful for temporary effects such as \"damage protection\".</p> DurationEffect.h<pre><code>class ABILITYSYSTEM_API UDurationEffect : public UEffect\n</code></pre> <p>You can adjust the time of the effect in Blueprints by changing the \u2018Time\u2019 field.</p> DurationEffect.h<pre><code>UPROPERTY(BlueprintReadWrite,\n    EditDefaultsOnly,\n    meta=(UIMin=\"0.0001\",\n        ClampMin=\"0.0001\"),\n    Category=\"DurationEffect\")\nfloat Time;\n</code></pre>"},{"location":"plugins/ability-system/#periodiceffect","title":"PeriodicEffect","text":"<p>This effect inherits UDurationEffect, but has the same tick logic as PeriodicInstantEffect.</p> <p>Tip</p> <p>Can be useful for effects like \u2018Health Regeneration\u2019, where the effect restores 25 health every second, but disappears after 5 seconds.</p> PeriodicEffect.h<pre><code>class ABILITYSYSTEM_API UPeriodicEffect : public UDurationEffect\n</code></pre> PeriodicEffect.h<pre><code>UFUNCTION(BlueprintNativeEvent)\nvoid PeriodTick();\n</code></pre>"},{"location":"plugins/ability-system/#ability-system-component","title":"Ability System Component","text":"<p>This class is the main manager in the effects and attributes system. It contains effects and attributes as an array of objects and operates them.</p> ASComponent.h<pre><code>class ABILITYSYSTEM_API UASComponent : public UActorComponent\n</code></pre> <pre><code>flowchart LR\n    UASComponent --&gt;|TArray| Effects\n    UASComponent --&gt;|TArray| Attributes\n\n    subgraph Effects\n        Effect1\n        Effect2\n        ...\n    end\n\n    subgraph Attributes\n        Attr1\n        Attr2\n        ...\n    end</code></pre> <p>Warning</p> <p>Since this is a actor component, there is no limit to the number of component per actor, but 1 manager per 1 actor is recommended. This will make it easier to manipulate objects</p> <p>There are some events that can be useful for tracking the status of Ability System Component:</p> <ul> <li>OnEffectAdded</li> <li>OnEffectStacked</li> <li>OnEffectRemoved</li> <li>OnEffectListUpdated</li> <li>OnAttributeAdded</li> <li>OnAttributeRemoved</li> <li>OnAttributeListUpdated</li> </ul> <p>Tip</p> <p>You can overwrite any methods in a class for custom managers</p>"},{"location":"plugins/ability-system/#attribute-management","title":"Attribute Management","text":"<p>You can use the following methods to handle the attributes of this component:</p> <ul> <li>Add Attribute</li> <li>Remove Attribute</li> <li>Get Attribute</li> <li>Has Attribute</li> <li>Get Attribute List</li> </ul>"},{"location":"plugins/ability-system/#add-attribute","title":"Add Attribute","text":"<p>This method adds a new attribute on a class basis. You will be able to edit the attribute after adding it.</p> ASComponent.h<pre><code>virtual UAttribute* AddAttribute(TSubclassOf&lt;UAttribute&gt; AttributeClass);\n</code></pre> <p>Notification system</p> <p>All attributes and all effects will be notified of the new attribute and that the attribute list has changed.     <pre><code>for (int32 i = 0; i &lt; n; ++i)\n{\n    Attributes[i]-&gt;OnAttributeAdded(temp);\n    Attributes[i]-&gt;OnAttributeListUpdated();\n}\n</code></pre></p> <p>Duplicate exception</p> <p>You can only add one attribute of a single class. If you try to add another duplicate, the method will ignore the attempt and return nullptr.     <pre><code>if (IsValid(entity) &amp;&amp; entity-&gt;IsA(AttributeClass)) return nullptr;\n</code></pre></p>"},{"location":"plugins/ability-system/#remove-attribute","title":"Remove Attribute","text":"<p>The methods remove the attribute from the attribute array.</p> ASComponent.h<pre><code>virtual void RemoveAttributeByEntity(UAttribute* InAttribute);\nvirtual void RemoveAttributeByClass(TSubclassOf&lt;UAttribute&gt; AttributeClass);\n</code></pre> <p>Notification system</p> <p>All attributes and all effects will be notified of the selected attribute and that the attribute list has changed.</p> <p>Memory clearing</p> <p>The object is cleared from memory after deletion and is no longer available. Make sure you clear memory (timers, allocated memory within the object, linked systems, etc.)</p>"},{"location":"plugins/ability-system/#get-attribute","title":"Get Attribute","text":"<p>The method returns the first attribute in the list that matches the class. If there are two attributes with the same class in the array, it will return the first one. </p> ASComponent.h<pre><code>virtual UAttribute* GetAttribute(TSubclassOf&lt;UAttribute&gt; AttributeClass);\n</code></pre> <p>Object Class</p> <p>The object class check is performed as follows: <pre><code>if (IsValid(attribute) &amp;&amp; attribute-&gt;IsA(AttributeClass))\n</code></pre></p> <p>Nullptr return</p> <p>Returns nullptr if the attribute could not be found.</p>"},{"location":"plugins/ability-system/#has-attribute","title":"Has Attribute","text":"<p>Checks if the attribute is in the list. Uses GetAttribute() to get the attribute. ASComponent.h<pre><code>virtual bool HasAttribute(TSubclassOf&lt;UAttribute&gt; AttributeClass) const;\n</code></pre></p>"},{"location":"plugins/ability-system/#get-attribute-list","title":"Get Attribute List","text":"<p>Getter for a list of attributes. Returns the current state of attribute list</p> ASComponent.h<pre><code>virtual void GetAttributeList(TArray&lt;UAttribute*&gt;&amp; OutAttributes);\n</code></pre>"},{"location":"plugins/ability-system/#attribute-execution-order","title":"Attribute Execution order","text":"Add Attribute Exeuction OrderRemove Attribute Execution Order <pre><code>1. Attributes.Add()\n2. Attribute-&gt;StartWork()\n3. Attributes:  OnAttributeAdded, OnAttributeListUpdated\n4. Effects:     OnAttributeAdded, OnAttributeListUpdated\n5. OnAttributeAdded.Broadcast()\n6. OnAttributeListUpdated.Broadcast()\n</code></pre> <pre><code>1. OnWorkEnded()\n2. Attributes:  OnAttributeRemoving()\n3. Effects:     OnAttributeRemoving()\n4. OnAttributeRemoved.Broadcast()\n5. Attribute-&gt;ConditionalBeginDestroy()\n6. Attributes.RemoveAt(index)\n7. Attributes:  OnAttributeListUpdated()\n8. Effects:     OnAttributeListUpdated()\n9. OnAttributeListUpdated.Broadcast()\n</code></pre>"},{"location":"plugins/ability-system/#effect-management","title":"Effect Management","text":"<p>You can use the following methods to handle the attributes of this component:</p> <ul> <li>Add Effect</li> <li>Remove Effect</li> <li>Get Effect</li> <li>Has Effect</li> <li>Get Effect List</li> </ul>"},{"location":"plugins/ability-system/#add-effect","title":"Add Effect","text":"<p>The method adds the effect to the list of effects.</p> ASComponent.h<pre><code>virtual UEffect* AddEffect(TSubclassOf&lt;UEffect&gt; EffectClass);\n</code></pre> <p>Notification system</p> <p>All attributes and all effects will be notified of the selected effect and that the effect list has changed.</p> <p>Stacking</p> <p>If a duplicate effect by class is found, it will try to call Stack().</p> <p>a. If Stack is successful, OnEffectStacked() will be called.</p> <p>b. If Stack is not possible, the temporary object will be deleted and the method will return nullptr.</p>"},{"location":"plugins/ability-system/#remove-effect","title":"Remove Effect","text":"<p>The methods remove the effect from the effects array.</p> ASComponent.h<pre><code>virtual void RemoveEffectByEntity(const UEffect* InEffect);\nvirtual void RemoveEffectByClass(TSubclassOf&lt;UEffect&gt; EffectClass);\n</code></pre> <p>Notification system</p> <p>All attributes and all effects will be notified of the selected effect and that the effect list has changed.</p> <p>Memory clearing</p> <p>The object is cleared from memory after deletion and is no longer available. Make sure you clear memory (timers, allocated memory within the object, linked systems, etc.)</p> <p>Effect life cycle</p> <p>You don't have to remove the effect from its owner component. You just need to call EndWork() on the effect.</p> <p>This will call the EffectHasEnded(this) method of the effect owner (GetOwningComponent()), which will properly clear memory and remove the effect from the array by calling OnWorkEnded() and ConditionalBeginDestroy() on it</p>"},{"location":"plugins/ability-system/#get-effect","title":"Get Effect","text":"<p>The method returns the first effect in the list that matches the class. If there are two effects with the same class in the array, it will return the first one. </p> ASComponent.h<pre><code>virtual UEffect* GetEffect(TSubclassOf&lt;UEffect&gt; EffectClass);\n</code></pre> <p>Object Class</p> <p>The object class check is performed as follows: <pre><code>if (IsValid(ef) &amp;&amp; ef-&gt;IsA(EffectClass))\n</code></pre></p> <p>Nullptr return</p> <p>Returns nullptr if the effect could not be found.</p>"},{"location":"plugins/ability-system/#has-effect","title":"Has Effect","text":"<p>Checks if the effect is in the list. Uses GetEffect() to get the attribute.</p> ASComponent.h<pre><code>virtual bool HasEffect(TSubclassOf&lt;UEffect&gt; EffectClass) const;\n</code></pre>"},{"location":"plugins/ability-system/#get-effect-list","title":"Get Effect List","text":"<p>Getter for a list of effects. Returns the current state of effect list</p> ASComponent.h<pre><code>virtual void GetEffectList(TArray&lt;UEffect*&gt;&amp; OutEffects);\n</code></pre>"},{"location":"plugins/ability-system/#replication","title":"Replication","text":"<p>The plugin fully supports replication and uses the Unreal Push Network Model to optimise network.</p> <p>To replicate UObjects, the plugin uses ReplicatedObject.</p> <p>For full functionality, you must enable Push Model in the project and replicate the ASComponent in constructor <pre><code>AbilitySystemComponent = CreateDefaultSubobject&lt;UASComponent&gt;(TEXT(\"AS\"));\nAbilitySystemComponent-&gt;SetIsReplicated(true);\n</code></pre></p> DefaultEngine.ini<pre><code>[SystemSettings]\nnet.IsPushModelEnabled=1\nnet.PushModelSkipUndirtiedReplication=1\n</code></pre>"},{"location":"plugins/ability-system/#examples","title":"Examples","text":"<p>You can set specific values to any attribute if you have a need to dynamically configure each attribute for different actors.</p> AHumAbilityCharacter.cpp<pre><code>void AHumAbilityCharacter::AddDefaultAttributes_Implementation()\n{\n    const int32 n = DefaultAttributes.Num();\n    for (int32 i = 0; i &lt; n; ++i)\n    {\n        const FDefaultPlayerAttribute&amp; el = DefaultAttributes[i];\n        if (el.AttributeClass)\n        {\n            if (UAttribute* entity = AbilitySystemComponent-&gt;AddAttribute(el.AttributeClass))\n            {\n                UAttributeSettingsDataAsset* settings = el.Settings.LoadSynchronous();\n                if (IsValid(settings))\n                {\n                    ApplySettingsForAttribute(entity, settings);\n                }\n            }\n        }\n    }\n}\n\n\nvoid AHumAbilityCharacter::ApplySettingsForAttribute_Implementation(\n    UAttribute* InAttribute,\n    UAttributeSettingsDataAsset* InSettings)\n{\n    if (IsValid(InAttribute) &amp;&amp; IsValid(InSettings))\n    {\n        InAttribute-&gt;SetMinValue(InSettings-&gt;MinValue);\n        InAttribute-&gt;SetMaxValue(InSettings-&gt;MaxValue);\n        InAttribute-&gt;SetValue(InSettings-&gt;InitialValue);\n    }\n}\n</code></pre> <p>You can cache frequently used attributes to make it easier to retrieve them in future code.</p> AHumAbilityCharacter.cpp<pre><code>TObjectPtr&lt;UAttribute&gt; AHumAbilityCharacter::GetHealth() const\n{\n    if (!HealthAttribute || !IsValid(HealthAttribute.Get()))\n    {\n        if (AbilitySystemComponent)\n        {\n            // Remove const from the current object to modify HealthAttribute\n            auto nonConstThis = const_cast&lt;AHumAbilityCharacter*&gt;(this);\n            nonConstThis-&gt;HealthAttribute = AbilitySystemComponent-&gt;Attribute(UHealthAttribute::StaticClass());\n        }\n    }\n    return HealthAttribute;\n}\n</code></pre> <p>You can bind to attribute events after you have added them to list.</p> AHumAbilityCharacter.cpp<pre><code>void AHumAbilityCharacter::BeginPlay()\n{\n    Super::BeginPlay();\n    if (HasAuthority())\n    {\n        AddDefaultAttributes();\n        AddDefaultEffects();\n        if (TObjectPtr&lt;UAttribute&gt; hp = GetHealth())\n        {\n            hp-&gt;OnValueMinThresholdReached.AddDynamic(this, &amp;AHumAbilityCharacter::OnHpLost);\n        }\n    }\n}\n</code></pre> <p>Authority</p> <p>Working with attributes and effects is possible only on the server. Check HasAuthority() before calling methods.</p> <p>Replication</p> <p>Attributes and Effects are replicated, so it is possible to find out the state of an entity on the client side.</p> <p>You can change the value of the attributes as you like.</p> AHumAbilityCharacter.cpp<pre><code>hp-&gt;SetValue(hp-&gt;GetCurrentValue() - FMath::Abs(Amount));\n</code></pre> <p>Note</p> <p>An attribute value cannot be greater than MaxValue, and less than MinValue. It will be clamped.</p>"},{"location":"plugins/actor-pool/","title":"Actor Pool","text":""},{"location":"plugins/actor-pool/#overview","title":"Overview","text":"<p>Github Repository</p> <p>The ActorPool plugin provides a flexible and efficient system for managing a pool of reusable actors. By utilizing an object pooling pattern, this plugin allows developers to optimize performance by reusing actors instead of repeatedly spawning and destroying them. The plugin is written in C++ and is fully customizable via Blueprints, making it suitable for both programmers and designers.</p>"},{"location":"plugins/actor-pool/#features","title":"Features","text":"<ul> <li>Object Pooling: Efficiently manage a pool of actors to reduce instantiation overhead.</li> <li>Blueprint Support: Functions like GetActorFromPool, ReturnActor, and MakeActor are exposed to Blueprints for easy customization.</li> <li>Network Replication: The pool and active actor lists are replicated for multiplayer compatibility.</li> <li>Customizable Pool Initialization: Configure pool size, initialization behavior, and spawning options via Blueprint properties.</li> <li>Extensible: Override MakeActor and InitializePool in C++ or Blueprints to tailor actor creation and pool setup.</li> </ul>"},{"location":"plugins/actor-pool/#ipoolable","title":"IPoolable","text":"<p>Note</p> <p>The actor that is created by AAbstractActorPool must implement an IPoolable interface</p> <p>When a pool is created, each actor will have a DeActivePoolActor() called. DeActivePoolActor() also called when the object is removed back to the pool.</p> <p>To retrieve an actor from the pool, you can use  <pre><code>AActor* AAbstractActorPool::GetActorFromPool()\n</code></pre></p> <p>This will call ActivatePoolActor() on the actor.</p> <p>If there are no free actors in the pool, MakeActor() will be called.</p>"},{"location":"plugins/actor-pool/#makeactor","title":"MakeActor()","text":"<p>You must overwrite MakeActor() in your pool. It will be called when you want to initialise the pool or add a new actor to the pool.</p> <p>ActivatePoolActor()</p> <p>Do not use BeginPlay() for initialization. The objects are created empty and only ActivatePoolActor() activates them.</p>"},{"location":"plugins/actor-pool/#replication","title":"Replication","text":"<p>The plugin fully supports replication and uses the Unreal Push Network Model to optimize network.</p>"},{"location":"plugins/actor-pool/#c-example","title":"C++ Example","text":"<pre><code>// Example of using the pool in C++\nAAbstractActorPool* Pool = GetWorld()-&gt;SpawnActor&lt;AAbstractActorPool&gt;();\nAActor* PooledActor = Pool-&gt;GetActorFromPool();\nif (PooledActor)\n{\n    // Use the actor (e.g., set location, activate behavior)\n    PooledActor-&gt;SetActorLocation(FVector(100, 100, 100));\n}\n\n// When done, return the actor to the pool\nPool-&gt;ReturnActor(PooledActor);\n</code></pre>"},{"location":"plugins/actor-pool/#riftborn-example","title":"Riftborn Example","text":"HumWeaponCharacter.cpp<pre><code>if (ABloodEffectActor* bloodEffect = Cast&lt;ABloodEffectActor&gt;(bloodEffectPool-&gt;GetActorFromPool()))\n{\n    bloodEffect-&gt;SetActorLocation(InLoc);\n    bloodEffect-&gt;PlayEffect(InType);\n}\n</code></pre>"},{"location":"plugins/actor-pool/#limitations","title":"Limitations","text":"<ul> <li>Actors in the pool must implement the IPoolable interface to ensure proper activation and deactivation.</li> <li>The plugin assumes actors are lightweight and suitable for pooling. Heavy actors with complex initialization may require additional optimization.</li> <li>Network replication is supported, but ensure proper testing in multiplayer scenarios to avoid synchronization issues.</li> </ul>"},{"location":"plugins/advanced-asset/","title":"Advanced Asset","text":""},{"location":"plugins/advanced-asset/#about-the-plugin","title":"About the plugin","text":"<p>Github Repository</p> <p>Author plugin written for Riftborn. It implements the custom Primary Asset for more convenient and efficient management of assets in the game.</p>"},{"location":"plugins/advanced-asset/#overview","title":"Overview","text":"<p>The plugin adds a UAdvancedDataAsset that inherits from the UPrimaryDataAsset.</p> <pre><code>classDiagram\n    UPrimaryDataAsset &lt;|-- UAdvancedDataAsset\n    UDataAsset &lt;|-- UPrimaryDataAsset</code></pre> <p>Note</p> <p>UPrimaryDataAsset is DataAsset that implements GetPrimaryAssetId and has asset bundle support, which allows it to be manually loaded/unloaded from the AssetManager.</p> <p>UAdvancedDataAsset Uses GetPrimaryAssetId() and generates the ID as follows:</p> <pre><code>FPrimaryAssetId(FPrimaryAssetType(AssetType), AssetId)\n</code></pre>"},{"location":"plugins/advanced-asset/#asset-type","title":"Asset Type","text":"<p>For the ID to be generated correctly, you must specify AssetType in the C++ constructor as follows:</p> MyAdvancedDataAsset.h<pre><code>class YOUR_API UMyAdvancedDataAsset : public UAdvancedDataAsset {\n    GENERATED_BODY()\npublic:\n  UMyAdvancedDataAsset();\n}\n</code></pre> MyAdvancedDataAsset.cpp<pre><code>UMyAdvancedDataAsset::UMyAdvancedDataAsset()\n{\n  AssetType = TEXT(\"MyAsset\");\n}\n</code></pre> <p>You can now create an instance of the date asset and specify the Asset ID</p> <p></p>"},{"location":"plugins/advanced-asset/#asset-manager","title":"Asset Manager","text":"<p>To load assets via FPrimaryAssetId(AssetType, AssetId) you need to register an asset in Asset Manager.</p> <p>Warning</p> <p>For each subclass of data-asset you need to specify a new asset type and register it in Asset Manager!</p> <p></p> <p>Note</p> <p>In the \"Primary Asset Type\", you must specify the asset type you specified in the constructor.</p> <p>In \"Asset Base Class\" you must specify the created C++ class</p> <p>Now you can load assets with just a Type and ID</p> MyAssetManager.h<pre><code>class YOUR_API UMyAssetManager : public UAssetManager\n{\n    GENERATED_BODY()\n\npublic:\n\n    template &lt;class T&gt;\n    T* LoadAsset(FName ID)\n    {\n        if (const UAdvancedDataAsset* Default = Cast&lt;UAdvancedDataAsset&gt;(T::StaticClass()-&gt;GetDefaultObject()))\n        {\n            const FPrimaryAssetId PrimaryAssetId = FPrimaryAssetId(Default-&gt;GetType(), ID);\n            const FSoftObjectPath path = GetPrimaryAssetPath(PrimaryAssetId);\n            if (T* LoadedItem = Cast&lt;T&gt;(path.TryLoad()))\n            {\n                return LoadedItem;\n            }\n        }\n        return nullptr;\n    }\n};\n</code></pre>"},{"location":"plugins/advanced-asset/#thumbnail-renderer","title":"Thumbnail renderer","text":"<p>You can select any icon from the project to display asset. You can also add a short name for the icon.</p> <p></p>"},{"location":"plugins/advanced-logger/","title":"Advanced Logger","text":""},{"location":"plugins/advanced-logger/#about-the-plugin","title":"About the plugin","text":"<p>Github Repository</p> <p>Author plugin written for Riftborn. It adds handy logging tools to C++ and Blueprints.</p> <p></p>"},{"location":"plugins/advanced-logger/#overview","title":"Overview","text":"<p>The plugin outputs both on the screen and in the console, displaying the name of the class in which the function was called.</p> <p></p>"},{"location":"plugins/advanced-logger/#settings","title":"Settings","text":"<p>You can customize the output categories in the project settings.</p> <p></p>"},{"location":"plugins/advanced-logger/#c-logs","title":"C++ Logs","text":"<p>The plugin also adds useful macros for use in C++</p> <pre><code>TRACE(YourCategory, \"My text with %s and %d\", *myString, myInt);\nTRACEWARN(YourCategory, \"My text with %s and %d\", *myString, myInt);\nTRACEERROR(YourCategory, \"My text with %s and %d\", *myString, myInt);\n</code></pre> <p>Warning</p> <p>These macros don't work in static functions and in places where GetWorld() can't be obtained!</p> <p>If you need to output something to console in a static function use the following:</p> <pre><code>TRACESTATIC(YourCategory, \"My text with %s and %d\", *myString, myInt);\n</code></pre> <p>Note</p> <p>In this case, the macro will not display your network mode (Standalone, Client, Server) in the console, but will still display the full name of the function.</p> <p>The plugin provides two macros for displaying on the screen:</p> <pre><code>SCREENDEBUG(\"My text with %s and %d\", *myString, myInt);  // Duration: 5.0f\nSCREENDEBUGT(\"My text with %s and %d\", *myString, myInt); // Duration: 0.0f\n</code></pre> <p>SCREENDEBUGT</p> <p>The second method  can be used in Tick()</p>"},{"location":"plugins/advanced-movement/","title":"Advanced Movement","text":""},{"location":"plugins/advanced-movement/#overview","title":"Overview","text":"<p>Github Repository</p> <p>Author plugin written for Riftborn. It adds handy movement logic for Character Movement Component.</p>"},{"location":"plugins/advanced-movement/#features","title":"Features","text":"<ul> <li>Replication</li> <li>Sprinting</li> <li>Dashing</li> </ul>"},{"location":"plugins/advanced-movement/#instructions","title":"Instructions","text":"<p>Inherit from UAdvancedMovementComponent to have all the features.</p> <p>The owner of the component must inherit from AAdvancedMovementCharacter.</p> <pre><code>class HUM_API UHumMovementComponent : public UAdvancedMovementComponent\n</code></pre> <p>Override GetMaxSpeed() to adjust max speed of Character.</p> <pre><code>if (IsMovingBackward())\n{\n    return IsCrouching() ? MaxBackwardWalkSpeedCrouched : MaxBackwardWalkSpeed;\n}\n</code></pre>"},{"location":"plugins/advanced-movement/#sprinting","title":"Sprinting","text":"<p>Use SprintPressed() to start the sprinting and SprintReleased() to stop sprinting.</p> <pre><code>enhancedInputComponent-&gt;BindAction(sprintAction,\n                                               ETriggerEvent::Started,\n                                               this,\n                                               &amp;AHumBaseCharacter::SprintPressed);\n</code></pre> <pre><code>void AHumBaseCharacter::SprintReleased(const FInputActionValue&amp; InValue)\n{\n    AdvancedMovementComponent-&gt;SprintReleased();\n}\n\nvoid AHumBaseCharacter::SprintPressed(const FInputActionValue&amp; InValue)\n{\n    if (IsAbleToHandleInput())\n    {\n        AdvancedMovementComponent-&gt;SprintPressed();\n    }\n}\n</code></pre> <p>Sprint is allowed only if IsSprintingAllowed() returns true.</p> <pre><code>bool UAdvancedMovementComponent::IsSprintingAllowed() const\n{\n    return !IsCrouching() \n        &amp;&amp; !IsFalling() \n        &amp;&amp; !IsCustomMovementMode(CMOVE_Slide)\n        &amp;&amp; IsMovingOnGround() \n        &amp;&amp; Velocity.SizeSquared() &gt;= 100.0f \n        &amp;&amp; !Safe_bWantsToSprint\n        &amp;&amp; AdvancedCharacter-&gt;CanSprint(); \n}\n</code></pre> <p>Note</p> <p>It also calls AdvancedCharacter CanSprint(). This can be useful for adding additional conditions</p> <p>Note</p> <p>You can check if the character wants to run in GetMaxSpeed() to set it to the desired speed</p> <pre><code>IsMovementMode(MOVE_Walking) &amp;&amp; Safe_bWantsToSprint\n</code></pre>"},{"location":"plugins/advanced-movement/#dashing","title":"Dashing","text":"<p>Use DashPressed() and DashReleased() to perform Dash.</p> <p>Note</p> <p>This must be executed on the client to replicate properly</p> <p>CanDash() determines whether the character can currently Dash or not.</p> <pre><code>bool UAdvancedMovementComponent::CanDash() const\n{\n    return IsWalking() &amp;&amp;\n        !IsSprinting() &amp;&amp;\n        !IsSliding() &amp;&amp;\n        !IsCrouching() &amp;&amp;\n        !IsFalling() &amp;&amp; AdvancedCharacter-&gt;CanDash();\n}\n</code></pre> <p>Note</p> <p>It also calls CanDash() from AdvancedCharacter. This is useful if you want to add conditions for performing a Dash</p>"},{"location":"plugins/advanced-sessions/","title":"Advanced Sessions","text":""},{"location":"plugins/advanced-sessions/#overview","title":"Overview","text":"<p>A Blueprint Library Plugin that exposes additional Networking/Session/OnlineSubsystem/Friends/Voice features to Blueprints that were missing.</p> <ul> <li>Unreal Engine Forum</li> <li>Github Repo</li> <li>Docs</li> </ul>"},{"location":"plugins/advanced-sessions/#examples","title":"Examples","text":"<p>Riftborn uses many helper methods from these libraries.</p> Calculate players hash<pre><code>TArray&lt;TObjectPtr&lt;APlayerState&gt;&gt; copy = InPlayers;\nuint32 hash = 0;\n\nfor (int32 i = 0; i &lt; copy.Num(); ++i)\n{\n    FBPUniqueNetId netId;\n    UAdvancedSessionsLibrary::GetUniqueNetIDFromPlayerState(copy[i].Get(), netId);\n\n    FString id;\n    UAdvancedSessionsLibrary::UniqueNetIdToString(netId, id);\n\n    hash = FCrc::StrCrc32(*id, hash);\n    if (AHumPlayerState* item = Cast&lt;AHumPlayerState&gt;(copy[i].Get()))\n    {\n        FString team = UEnum::GetValueAsString(item-&gt;GetTeam());\n        hash = FCrc::StrCrc32(*team, hash);\n\n        FString selectedChar = item-&gt;GetSelectedCharacter().PrimaryAssetName.ToString();\n        hash = FCrc::StrCrc32(*selectedChar, hash);\n    }\n}\nreturn hash;\n</code></pre> Player killed someone<pre><code>FBPUniqueNetId a;\nUAdvancedSessionsLibrary::GetUniqueNetIDFromPlayerState(PlayerInstigator, a);\nFBPUniqueNetId b;\nUAdvancedSessionsLibrary::GetUniqueNetIDFromPlayerState(PlayerInstigator, b);\n\nFString aStr;\nUAdvancedSessionsLibrary::UniqueNetIdToString(a, aStr);\nFString bStr;\nUAdvancedSessionsLibrary::UniqueNetIdToString(b, bStr);\n\nTRACE(LogHUM, \"%s (%s) has killed %s (%s)\",\n    *PlayerInstigator-&gt;GetPlayerName(),\n    *aStr,\n    *PlayerInstigator-&gt;GetPlayerName(),\n    *bStr);\n</code></pre>"},{"location":"plugins/blueprint-compile/","title":"Blueprint Compile","text":"<p>Github Repository</p> <p></p>"},{"location":"plugins/blueprint-compile/#overview","title":"Overview","text":"<p>The plugin allows you to compile all blueprints in project in one click with all errors and logs displayed.</p> <p>If you often edit C++ code, you may have noticed that blueprints break and generate errors related to modified .h files. This often happens if the project is huge and the engine does not even show errors tab when trying to run the game in the PIE.</p> <p>You can simply compile the project in Shipping Build in case of strange behavior of Blueprints, but it may take a lot of time.</p>"},{"location":"plugins/blueprint-compile/#window","title":"Window","text":"<p>To compile all Blueprints in a project, go to Window -&gt; BlueprintCompiler</p> <p></p>"},{"location":"plugins/data-serializer/","title":"Data Serializer","text":"<p>Github Repository</p>"},{"location":"plugins/data-serializer/#overview","title":"Overview","text":"<p>A set of utilities for convenient data serialization</p>"},{"location":"plugins/data-serializer/#data-serializer-lib","title":"Data Serializer Lib","text":"<pre><code>class DATASERIALIZER_API UDataSerializerLib : public UBlueprintFunctionLibrary\n</code></pre> <p>Features:</p> <ul> <li>WriteBytesToDisk, WriteBytesToDiskCompressed</li> <li>ReadBytesFromDisk, ReadCompressedBytesFromDisk</li> <li>SerializeObject, DeserializeObject</li> <li>SerializeObjects, DeSerializeObjects</li> <li>GetUtf8Bytes, Utf8BytesToString</li> </ul>"},{"location":"plugins/data-serializer/#write-bytes","title":"Write Bytes","text":"<p>You can write an array of bytes to disk using the following functions.</p> <pre><code>static bool WriteBytesToDisk(const TArray&lt;uint8&gt;&amp; InBytes, FString InPath);\nstatic bool WriteBytesToDiskCompressed(const TArray&lt;uint8&gt;&amp; InBytes, FString InPath);\n</code></pre> <p>Note</p> <p>WriteBytesToDiskCompressed will write compressed bytes to disk, which will weigh less than the original byte array</p>"},{"location":"plugins/data-serializer/#read-bytes","title":"Read Bytes","text":"<p>You can load an array of bytes from disk using the following functions.</p> <pre><code>static bool ReadBytesFromDisk(TArray&lt;uint8&gt;&amp; OutBytes, FString InPath);\nstatic bool ReadCompressedBytesFromDisk(TArray&lt;uint8&gt;&amp; OutBytes, FString InPath);\n</code></pre> <p>Note</p> <p>ReadCompressedBytesFromDisk should be used if the bytes were written using WriteBytesToDiskCompressed</p>"},{"location":"plugins/data-serializer/#serialize","title":"Serialize","text":"<p>Warning</p> <p>FObjectAndNameAsStringProxyArchive and FSerializationHeader are used for object serialization</p> <p>You can serialize a single object into bytes using the following function.</p> <pre><code>static bool SerializeObject(TArray&lt;uint8&gt;&amp; OutBytes, UObject* InObject);\n</code></pre> <p>Note</p> <p>UObject::Serialize() is used to serialize an object into bytes. Overwrite it for custom serialization or use UPROPERTY for default data types.</p> <p>You can serialize an array of objects into bytes.</p> <pre><code>static bool SerializeObjects(TArray&lt;uint8&gt;&amp; OutBytes, TArray&lt;UObject*&gt; InObjects);\n</code></pre> <p>Info</p> <p>At the beginning of the record will be the size of the array for further correct loading from disk.</p>"},{"location":"plugins/data-serializer/#deserialize","title":"Deserialize","text":"<p>You can deserialize an array of bytes into an object or array of objects.</p> <p>Tip</p> <p>Use DeSerializeObjects() if you firstly used SerializeObjects().</p> <pre><code>static bool DeserializeObject(const TArray&lt;uint8&gt;&amp; InBytes, UObject* ObjectOuter, UObject*&amp; OutObject);\nstatic bool DeSerializeObjects(const TArray&lt;uint8&gt;&amp; InBytes, UObject* InObjectOuter, TArray&lt;UObject*&gt;&amp; OutObjects);\n</code></pre> <p>Note</p> <p>Will return false if the bytes were invalid.</p>"},{"location":"plugins/data-serializer/#utf8-bytes","title":"UTF8 Bytes","text":"<p>UTF8 encoding is often used to transmit string bytes over a network.</p> <p>Use the following methods to serialize a FString into UTF8 bytes and back bytes into a FString</p> <pre><code>static void GetUtf8Bytes(const FString&amp; InString, TArray&lt;uint8&gt;&amp; OutBytes);\nstatic FString Utf8BytesToString(const TArray&lt;uint8&gt;&amp; InBytes);\n</code></pre>"},{"location":"plugins/data-serializer/#serialize-deserialize-object","title":"Serialize / Deserialize Object","text":"<p>You can use USerializerObject and UDeSerializerObject for more convenience workflow in Blueprints.</p> <p>This is a wrapper over FMemoryWriter and FMemoryReader</p>"},{"location":"plugins/data-serializer/#serialize-object","title":"Serialize Object","text":"<p>Wrapper of FMemoryWriter</p> <p>Features:</p> <ul> <li>Clear</li> <li>Prepare</li> <li>GetBytes</li> <li>PushBytes</li> <li>Serialize (int32, int64, float, double, bool, vector, vector2d, point, rotator, transform, string, object, objects[])</li> </ul>"},{"location":"plugins/data-serializer/#clear","title":"Clear","text":"<p>Clears all data and the pointer to MemoryWriter.</p> <pre><code>virtual void Clear();\n</code></pre>"},{"location":"plugins/data-serializer/#prepare","title":"Prepare","text":"<p>Clears the data and creates a new MemoryWriter.</p> <pre><code>virtual void Prepare();\n</code></pre>"},{"location":"plugins/data-serializer/#getbytes","title":"GetBytes","text":"<p>Getter for bytes. Returns the current array with bytes. Useful for writing bytes to disk after all data has been serialized</p> <pre><code>virtual void GetBytes(TArray&lt;uint8&gt;&amp; OutBytes);\n</code></pre>"},{"location":"plugins/data-serializer/#pushbytes","title":"PushBytes","text":"<p>Appends bytes to the current byte array.</p> <p>Useful in conjunction with UDataSerializerLib.</p> <pre><code>virtual void PushBytes(const TArray&lt;uint8&gt;&amp; InBytes);\n</code></pre>"},{"location":"plugins/data-serializer/#serialize_1","title":"Serialize","text":"<p>Write bytes to an array of bytes using the &lt;&lt; operator of FMemoryWriter.</p> <pre><code>void USerializerObject::SerializeInt(int32 InInteger) { GetMemoryWriterRef() &lt;&lt; InInteger; }\nvoid USerializerObject::SerializeBigInt(int64 InBigInt) { GetMemoryWriterRef() &lt;&lt; InBigInt; }\nvoid USerializerObject::SerializeFloat(float InFloat) { GetMemoryWriterRef() &lt;&lt; InFloat; }\nvoid USerializerObject::SerializeDouble(double InDouble) { GetMemoryWriterRef() &lt;&lt; InDouble; }\nvoid USerializerObject::SerializeBool(bool InBool) { GetMemoryWriterRef() &lt;&lt; InBool; }\nvoid USerializerObject::SerializeByte(uint8 InByte) { GetMemoryWriterRef() &lt;&lt; InByte; }\nvoid USerializerObject::SerializeVector(FVector InVector) { GetMemoryWriterRef() &lt;&lt; InVector; }\nvoid USerializerObject::SerializeIntVector(FIntVector InVector) { GetMemoryWriterRef() &lt;&lt; InVector; }\nvoid USerializerObject::SerializeVector2D(FVector2D InVector) { GetMemoryWriterRef() &lt;&lt; InVector; }\nvoid USerializerObject::SerializePoint(FIntPoint InPoint) { GetMemoryWriterRef() &lt;&lt; InPoint; }\nvoid USerializerObject::SerializeRotator(FRotator InRotator) { GetMemoryWriterRef() &lt;&lt; InRotator; }\nvoid USerializerObject::SerializeTransform(FTransform InTransform) { GetMemoryWriterRef() &lt;&lt; InTransform; }\nvoid USerializerObject::SerializeString(FString InString) { GetMemoryWriterRef() &lt;&lt; InString; }\n</code></pre>"},{"location":"plugins/data-serializer/#deserialize-object","title":"DeSerialize Object","text":"<p>Wrapper of FMemoryReader</p> <p>Features:</p> <ul> <li>Clear</li> <li>Start</li> <li>Try Read</li> </ul>"},{"location":"plugins/data-serializer/#clear_1","title":"Clear","text":"<p>Resets FMemoryReader pointer.</p> <pre><code>virtual void Clear();\n</code></pre>"},{"location":"plugins/data-serializer/#start","title":"Start","text":"<p>Clears the data and creates a new MemoryReader.</p> <pre><code>virtual void Start(const TArray&lt;uint8&gt;&amp; InBytes);\n</code></pre>"},{"location":"plugins/data-serializer/#c-try-read","title":"C++ Try Read","text":"<p>It tries to turn deserialize current bytes into a specific data type using the &lt;&lt; operator of FMemoryReader</p> <pre><code>template &lt;typename T&gt;\nbool TryReadT(T&amp; OutValue);\n</code></pre> <p>Warning</p> <p>Returns false if FMemoryReader returned IsError() or IsCriticalError()</p>"},{"location":"plugins/data-serializer/#blueprints-try-read","title":"Blueprints Try Read","text":"<p>Uses TryReadT(...) to return a specific type in blueprints.</p> <p>UDataSerializerLib is used for object deserialization</p> <pre><code>bool UDeSerializerObject::TryReadInt(int32&amp; OutInt) { return TryReadT(OutInt); }\nbool UDeSerializerObject::TryReadInt64(int64&amp; OutInt64) { return TryReadT(OutInt64); }\nbool UDeSerializerObject::TryReadFloat(float&amp; OutFloat) { return TryReadT(OutFloat); }\nbool UDeSerializerObject::TryReadDouble(double&amp; OutDouble) { return TryReadT(OutDouble); }\nbool UDeSerializerObject::TryReadBool(bool&amp; OutBool) { return TryReadT(OutBool); }\nbool UDeSerializerObject::TryReadUInt8(uint8&amp; OutUInt8) { return TryReadT(OutUInt8); }\nbool UDeSerializerObject::TryReadVector(FVector&amp; OutVector) { return TryReadT(OutVector); }\nbool UDeSerializerObject::TryReadIntVector(FIntVector&amp; OutIntVector) { return TryReadT(OutIntVector); }\nbool UDeSerializerObject::TryReadVector2D(FVector2D&amp; OutVector2D) { return TryReadT(OutVector2D); }\nbool UDeSerializerObject::TryReadIntPoint(FIntPoint&amp; OutIntPoint) { return TryReadT(OutIntPoint); }\nbool UDeSerializerObject::TryReadRotator(FRotator&amp; OutRotator) { return TryReadT(OutRotator); }\nbool UDeSerializerObject::TryReadTransform(FTransform&amp; OutTransform) { return TryReadT(OutTransform); }\nbool UDeSerializerObject::TryReadString(FString&amp; OutString) { return TryReadT(OutString); }\nbool UDeSerializerObject::TryReadObject(UObject* InObjectOuter, UObject*&amp; OutObject)\n{\n    FMemoryReader&amp; memoryReader = GetMemoryReaderRef();\n    return UDataSerializerLib::DeSerializeObjectCpp(memoryReader, InObjectOuter, OutObject);\n}\n\nbool UDeSerializerObject::TryReadObjects(UObject* InObjectOuter, TArray&lt;UObject*&gt;&amp; OutObjects)\n{\n    FMemoryReader&amp; memoryReader = GetMemoryReaderRef();\n    return UDataSerializerLib::DeSerializeObjectsCpp(memoryReader, InObjectOuter, OutObjects);\n}\n</code></pre>"},{"location":"plugins/data-serializer/#example","title":"Example","text":"<pre><code>void UEasySettingsSubsystem::SaveContainer()\n{\n    if (!IsValid(SettingsSetter))\n        return;\n\n    // Prepare empty byte container\n    TArray&lt;uint8&gt; bytes;\n    FMemoryWriter writer(bytes);\n\n    // Write bytes from settings\n    SettingsSetter-&gt;Write(writer);\n\n    // Save to file\n    FString path = GetContainerSavePath();\n    UDataSerializerLib::WriteBytesToDiskCompressed(bytes, path);\n}\n\nvoid UEasySettingsSetter::Write(FMemoryWriter&amp; MemoryWriter)\n{\n    int n = EasySettings::VALUES_NUM;\n    check((Values.Num() == n))\n    // Write each float element\n    for (const TTuple&lt;EasySettings::MapKey, EasySettings::MapValue&gt;&amp; pair : Values)\n    {\n        bool bDefault = pair.Value.bDefaultValue;\n        MemoryWriter &lt;&lt; bDefault;\n        float value = pair.Value.Value;\n        MemoryWriter &lt;&lt; value;\n    }\n}\n</code></pre>"},{"location":"plugins/easy-settings/","title":"Easy Settings","text":"<p>Github Repository</p>"},{"location":"plugins/easy-settings/#overview","title":"Overview","text":"<p>A plugin that adds a subsystem that expands developers' options for game customization and makes it easier to develop certain settings.</p>"},{"location":"plugins/easy-settings/#developer-settings","title":"Developer Settings","text":"<p>Developer settings for the system,</p> EasySettingsSubsystemDeveloperSettings<pre><code>class EASYSETTINGS_API UEasySettingsSubsystemDeveloperSettings : public UDeveloperSettings\n</code></pre>"},{"location":"plugins/easy-settings/#settings-setter-class","title":"Settings Setter Class","text":"<p>Used to create an instance of UEasySettingsSetter.</p> <p>Change to your class to use its overwritten methods.</p> EasySettingsSubsystemDeveloperSettings<pre><code>TSubclassOf&lt;UEasySettingsSetter&gt; SettingsSetterClass;\n</code></pre>"},{"location":"plugins/easy-settings/#container-save-name","title":"Container Save Name","text":"<p>Used in <code>FString UEasySettingsSubsystem::GetContainerSavePath()</code>  to define the path to save the file.</p> <p>Specify any file name and it will be saved to <code>GetProjectDir()/ContainerSaveName</code></p> EasySettingsSubsystemDeveloperSettings<pre><code>FString ContainerSaveName;\n</code></pre>"},{"location":"plugins/easy-settings/#easy-settings-setter","title":"Easy Settings Setter","text":"<pre><code>class EASYSETTINGS_API UEasySettingsSetter : public UObject\n</code></pre> <p>A class that manages categorized float values.</p> <p>UEasySettingsSetter is designed to store, retrieve, and serialize float values that are categorized by an <code>uint8</code> key. It provides functionality to initialize, set, get, read, and write these categorized values.</p> EasySettingsSetter.h<pre><code>namespace EasySettings\n{\n    constexpr int32 VALUES_NUM = 254;\n    typedef uint8 MapKey;\n    typedef FEasySettingsContainerValue MapValue;\n    typedef TMap&lt;EasySettings::MapKey, EasySettings::MapValue&gt; FContainer;\n}\n</code></pre> <p>The map allows for fast retrieval and update of float values based on their category.</p> EasySettingsSetter.h<pre><code>protected:\nEasySettings::FContainer Values;\n</code></pre> <p>Features: </p> <ul> <li>SetValue</li> <li>ResetValue</li> <li>GetValue</li> </ul>"},{"location":"plugins/easy-settings/#set-value","title":"Set Value","text":"<p>Sets the float value for a specific category. If the provided category exists in the Values map, this method updates the associated float value.</p> <p>Tip</p> <p>Overwrite this method and you will be able to handle every parameter set in blueprints</p> EasySettingsSetter.h<pre><code>void SetValue(uint8 InCategory, float InValue);\n</code></pre> <p>Warning</p> <p>If the category does not exist, no action is taken.</p>"},{"location":"plugins/easy-settings/#get-value","title":"Get Value","text":"<p>Retrieves the float value associated with a specific category.</p> <p>If the category exists, the method assigns the associated float value to the provided reference and returns true.</p> EasySettingsSetter.h<pre><code>virtual bool GetValue(uint8 InCategory, float&amp; OutValue, bool&amp; bOutDefault);\n</code></pre> <p>Warning</p> <p>If the category does not exist, the method returns false.</p>"},{"location":"plugins/easy-settings/#reset-value","title":"Reset Value","text":"<p>Resets value to default</p> <p>EasySettingsSetter.h<pre><code>void ResetValue(uint8 InCategory);\n</code></pre> EasySettingsSetter.cpp<pre><code>Values[InCategory].bDefaultValue = true;\nValues[InCategory].Value = 0.0f;\n</code></pre></p>"},{"location":"plugins/easy-settings/#easy-settings-subsystem","title":"Easy Settings Subsystem","text":"EasySettingsSubsystem.h<pre><code>class EASYSETTINGS_API UEasySettingsSubsystem : public UGameInstanceSubsystem\n</code></pre> <p>A subsystem that extends game settings, includes changing console variables and more.</p> <p>Features:</p> <ul> <li>SetSettingsQuality, GetSettingsQuality</li> <li>SetAntialiasingMethod, GetAntialiasingMethod</li> <li>SetOverallQualityLevel</li> <li>SetVsyncEnabled, GetVsyncEnabled</li> <li>SetFrameRateLimit, GetFrameRateLimit</li> <li>SetWindowedMode, GetCurrentWindowedMode, GetFullscreenMode</li> <li>SetResolution, GetCurrentResolution</li> <li>GetSupportedResolutions</li> <li>SetScreenPercentage, GetScreenPercentage</li> <li>SetContainerValue, GetContainerValue, ResetContainerValue</li> <li>ApplySettings</li> <li>ApplyContainer</li> </ul>"},{"location":"plugins/easy-settings/#esettingstype","title":"ESettingsType","text":"<p>An enumeration representing different types of graphical settings in the game.</p> <pre><code>enum class ESettingsType : uint8\n{\n    TYPE_NONE UMETA(Hidden),\n    TYPE_AA UMETA(DisplayName=\"Anti Aliasing\"),\n    TYPE_Textures UMETA(DisplayName=\"Textures\"),\n    TYPE_Effects UMETA(DisplayName=\"Effects\"),\n    TYPE_Shadows UMETA(DisplayName=\"Shadows\"),\n    TYPE_Foliage UMETA(DisplayName=\"Foliage\"),\n    TYPE_Reflection UMETA(DisplayName=\"Reflection\"),\n    TYPE_GlobalIllumination UMETA(DisplayName=\"Global Illumination\"),\n    TYPE_ViewDistance UMETA(DisplayName=\"View Distance\"),\n    /** Represents the maximum value for this enum, used internally. */\n    TYPE_MAX UMETA(Hidden)\n};\n</code></pre>"},{"location":"plugins/easy-settings/#set-settings-quality","title":"Set Settings Quality","text":"<p>Sets the quality values for the selected setting. </p> <p>Can be useful when using combo boxes together with ESettingsType enumeration.</p> EasySettingsSubsystem.h<pre><code>void SetSettingsQuality(ESettingsType InSettingsType = ESettingsType::TYPE_Effects, \n                        int32 InQuality = 3,\n                        bool bApply = true);\n</code></pre> <p>Note</p> <p>If bApply == true, it will call ApplySettings()</p>"},{"location":"plugins/easy-settings/#get-settings-quality","title":"Get Settings Quality","text":"<p>Retrieves the current quality level of a specific setting type.</p> EasySettingsSubsystem.h<pre><code>int32 GetSettingsQuality(ESettingsType InSettingsType = ESettingsType::TYPE_Effects) const;\n</code></pre>"},{"location":"plugins/easy-settings/#set-antialiasing-method","title":"Set Antialiasing Method","text":"<p>Sets the Anti-Aliasing method.</p> EasySettingsSubsystem.h<pre><code>void SetAntialiasingMethod(\n        APlayerController* InController,\n        int32 InValue,\n        bool bApply = true);\n</code></pre>"},{"location":"plugins/easy-settings/#get-antialiasing-method","title":"Get Antialiasing Method","text":"<p>Retrieves the current Anti-Aliasing method.</p> EasySettingsSubsystem.h<pre><code>int32 GetAntialiasingMethod() const;\n</code></pre>"},{"location":"plugins/easy-settings/#set-overall-quality-level","title":"Set Overall Quality Level","text":"<p>Sets the Overall quality level.</p> EasySettingsSubsystem.h<pre><code>void SetOverallQualityLevel(int32 InValue, bool bApply = true);\n</code></pre>"},{"location":"plugins/easy-settings/#set-vsync-enabled","title":"Set Vsync Enabled","text":"<p>Enables or disables VSync.</p> EasySettingsSubsystem.h<pre><code>void SetVsyncEnabled(bool bInValue, bool bApply = true);\n</code></pre>"},{"location":"plugins/easy-settings/#get-vsync-enabled","title":"Get Vsync Enabled","text":"<p>Checks whether VSync is currently enabled.</p> EasySettingsSubsystem.h<pre><code>bool GetVsyncEnabled() const;\n</code></pre>"},{"location":"plugins/easy-settings/#set-framerate-limit","title":"Set FrameRate Limit","text":"<p>Sets the frame rate limit.</p> EasySettingsSubsystem.h<pre><code>void SetFrameRateLimit(int32 InValue, bool bApply = true);\n</code></pre>"},{"location":"plugins/easy-settings/#get-framerate-limit","title":"Get FrameRate Limit","text":"<p>Retrieves the current frame rate limit.</p> EasySettingsSubsystem.h<pre><code>int32 GetFrameRateLimit() const;\n</code></pre>"},{"location":"plugins/easy-settings/#set-windowed-mode","title":"Set Windowed Mode","text":"<p>Sets the window mode (fullscreen, windowed, or borderless window).</p> EasySettingsSubsystem.h<pre><code>void SetWindowedMode(\n    TEnumAsByte&lt;EWindowMode::Type&gt; InWindowMode = EWindowMode::Type::Windowed,\n    bool bApply = true);\n</code></pre>"},{"location":"plugins/easy-settings/#get-current-windowed-mode","title":"Get Current Windowed Mode","text":"<p>Retrieves the current window mode.</p> EasySettingsSubsystem.h<pre><code>TEnumAsByte&lt;EWindowMode::Type&gt; GetCurrentWindowedMode() const;\n</code></pre>"},{"location":"plugins/easy-settings/#get-fullscreenmode","title":"Get FullscreenMode","text":"<p>This function returns the current fullscreen mode as configured in the game's settings. The possible modes include fullscreen, windowed, and borderless windowed.</p> EasySettingsSubsystem.h<pre><code>TEnumAsByte&lt;EWindowMode::Type&gt; GetFullscreenMode() const { return GetGameUserSettings()-&gt;GetFullscreenMode(); }\n</code></pre>"},{"location":"plugins/easy-settings/#set-resolution","title":"Set Resolution","text":"<p>Sets the screen resolution.</p> EasySettingsSubsystem.h<pre><code>void SetResolution(FIntPoint InResolution, bool bApply = true);\n</code></pre>"},{"location":"plugins/easy-settings/#get-current-resolution","title":"Get Current Resolution","text":"<p>Retrieves the current screen resolution.</p> EasySettingsSubsystem.h<pre><code>FIntPoint GetCurrentResolution() const;\n</code></pre>"},{"location":"plugins/easy-settings/#get-supported-resolutions","title":"Get Supported Resolutions","text":"<p>Retrieves the supported screen resolutions based on the selected window mode. EasySettingsSubsystem.h<pre><code>void GetSupportedResolutions(TArray&lt;FIntPoint&gt;&amp; OutResult,\n                                TEnumAsByte&lt;EWindowMode::Type&gt; InWindowMode = EWindowMode::Type::Windowed);\n</code></pre></p>"},{"location":"plugins/easy-settings/#set-screen-percentage","title":"Set Screen Percentage","text":"<p>Sets the screen percentage scaling factor for rendering.</p> EasySettingsSubsystem.h<pre><code>void SetScreenPercentage(int32 InValue = 100, bool bApply = true);\n</code></pre> <p>Note</p> <p>This function allows modifying the <code>r.ScreenPercentage</code> console variable,  which controls the resolution scale of the rendered scene.</p>"},{"location":"plugins/easy-settings/#get-screen-percentage","title":"Get Screen Percentage","text":"<p>Retrieves the current screen percentage scaling factor.</p> EasySettingsSubsystem.h<pre><code>int32 GetScreenPercentage() const;\n</code></pre> <p>Note</p> <p>This function reads the value of the <code>r.ScreenPercentage</code> console variable,  which determines the resolution scale used for rendering.</p>"},{"location":"plugins/easy-settings/#set-container-value","title":"Set Container Value","text":"<p>Sets the container value for a specific category.</p> EasySettingsSubsystem.h<pre><code>void SetContainerValue(uint8 InCategory, float InValue, bool bApply = true);\n</code></pre> <p>Note</p> <p>his method sets the float value for a given category in the container.  If the <code>bApply</code> flag is true, the settings are applied immediately after setting the value.</p>"},{"location":"plugins/easy-settings/#get-container-value","title":"Get Container Value","text":"<p>Retrieves the container value for a specific category.</p> EasySettingsSubsystem.h<pre><code>void GetContainerValue(uint8 InCategory, float&amp; OutValue,\n        bool&amp; bDefault);\n</code></pre>"},{"location":"plugins/easy-settings/#reset-container-value","title":"Reset Container Value","text":"<p>Resets the container value.</p> <p>EasySettingsSubsystem.h<pre><code>void ResetContainerValue(uint8 InCategory, bool bApply = true);\n</code></pre> <pre><code>void UEasySettingsSetter::ResetValue_Implementation(uint8 InCategory)\n{\n    if (Values.Contains(InCategory))\n    {\n        Values[InCategory].bDefaultValue = true;\n        Values[InCategory].Value = 0.0f;\n    }\n}\n</code></pre></p>"},{"location":"plugins/easy-settings/#apply-settings","title":"Apply Settings","text":"<p>Applies the current settings, saving them to the user's configuration file.</p> EasySettingsSubsystem.h<pre><code>void ApplySettings();\n</code></pre>"},{"location":"plugins/easy-settings/#apply-container","title":"Apply Container","text":"<p>Applies the current container values, saving them to the user's configuration file.</p> EasySettingsSubsystem.h<pre><code>void ApplyContainer();\n</code></pre>"},{"location":"plugins/replicated-object/","title":"Replicated Object","text":""},{"location":"plugins/replicated-object/#about-the-plugin","title":"About the plugin","text":"<p>Github Repository</p>"},{"location":"plugins/replicated-object/#overview","title":"Overview","text":"<p>As you may know Unreal Engine does not replicate UObjects. But in some solutions, such as inventory, it can come in handy very often.</p> <p>This plugin provides a simple solution to replicate UObjects.</p>"},{"location":"plugins/replicated-object/#instruction","title":"Instruction","text":"<p>To make replication work there are some steps that need to be followed.</p> <ol> <li> <p>Create a class that will inherit from UAdvancedReplicatedObject</p> MyReplicatedObject.h<pre><code>class YOUR_API UMyReplicatedObject : public UAdvancedReplicatedObject \n{\nGENERATED_BODY()\npublic:\nUMyReplicatedObject(const FObjectInitializer&amp; ObjectInitializer) : Super(ObjectInitializer) {}\nvirtual bool IsSupportedForNetworking() const override { return true; }\n}\n</code></pre> </li> <li> <p>Create a UPROPERTY variable with a pointer to your object.</p> MyActor.h<pre><code>class YOUR_API AMyActor : public AActor {\npublic:\nUPROPERTY(Replicated)\nclass UMyReplicatedObject* MyObjectPtr;\n}\n</code></pre> </li> <li> <p>Override GetLifetimeReplicatedProps(...) and ReplicateSubobjects(...) in your actor.</p> MyActor.h<pre><code>public:\nvirtual void GetLifetimeReplicatedProps(TArray&lt;class FLifetimeProperty&gt;&amp; OutLifetimeProps) const override;\nvirtual bool ReplicateSubobjects(UActorChannel* Channel, FOutBunch* Bunch, FReplicationFlags* RepFlags) override;\n</code></pre> MyActor.cpp<pre><code>void AMyActor::GetLifetimeReplicatedProps(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) const\n{\n    Super::GetLifetimeReplicatedProps(OutLifetimeProps);\n    DOREPLIFETIME(AMyActor, MyObjectPtr);\n}\n\nbool AMyActor::ReplicateSubobjects(UActorChannel* Channel, FOutBunch* Bunch, FReplicationFlags* RepFlags)\n{\n    bool sup = Super::ReplicateSubobjects(Channel, Bunch, RepFlags);\n    if (IsValid(MyObjectPtr))\n    {\n        sup |= Channel-&gt;ReplicateSubobject(MyObjectPtr, *Bunch, *RepFlags);\n        sup |= MyObjectPtr-&gt;ReplicateSubobjects(Channel, Bunch, RepFlags);\n    }\n    return sup;\n}\n</code></pre> </li> </ol>"},{"location":"plugins/replicated-object/#example","title":"Example","text":"<p>The object must be created on the server side.</p> MyActor.cpp<pre><code>void AMyActor::BeginPlay()\n{\n  Super::BeginPlay();\n  if (HasAuthority())\n  {\n    MyObjectPtr = NewObject&lt;UAdvancedReplicatedObject&gt;(this, UAdvancedReplicatedObject::StaticClass());\n  }\n}\n</code></pre> <p>Outer of UAdvancedReplicatedObject</p> <p>It is desirable to make the Outer of the object an Actor. Otherwise RPC will not work, and replication will work only if the Outer of your Outer is an Actor.</p>"},{"location":"plugins/replicated-object/#array-of-objects","title":"Array of objects","text":"<p>If you need to make an array, then create a array of pointers and replicate the data through the FOR.</p> ReplicatedActorExample.h<pre><code>class REPLICATEDOBJECT_API AReplicatedActorExample : public AActor {\n    GENERATED_BODY()\nprotected:\n    UPROPERTY(Replicated)\n    TArray&lt;UAdvancedReplicatedObject*&gt; MyArray;\n\npublic:\n    virtual void GetLifetimeReplicatedProps(TArray&lt;class FLifetimeProperty&gt;&amp; OutLifetimeProps) const override;\n    virtual bool ReplicateSubobjects(UActorChannel* Channel, FOutBunch* Bunch, FReplicationFlags* RepFlags) override;\n}\n</code></pre> ReplicatedActorExample.cpp<pre><code>void AReplicatedActorExample::BeginPlay()\n{\n    Super::BeginPlay();\n    if (HasAuthority())\n    {\n        MyArray.Add(MyObjectPtr = NewObject&lt;UAdvancedReplicatedObject&gt;(this, UAdvancedReplicatedObject::StaticClass()));\n        MyArray.Add(MyObjectPtr = NewObject&lt;UAdvancedReplicatedObject&gt;(this, UAdvancedReplicatedObject::StaticClass()));\n    }\n}\nvoid AReplicatedActorExample::GetLifetimeReplicatedProps(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) const\n{\n    Super::GetLifetimeReplicatedProps(OutLifetimeProps);\n    DOREPLIFETIME(AReplicatedActorExample, MyArray);\n}\nbool AReplicatedActorExample::ReplicateSubobjects(UActorChannel* Channel, FOutBunch* Bunch, FReplicationFlags* RepFlags)\n{\n    bool sup = Super::ReplicateSubobjects(Channel, Bunch, RepFlags);\n    int32 n = MyArray.Num();\n    if(n &gt; 0)\n    {\n        for(int32 i = 0; i &lt; n; ++i)\n        {\n            sup |= Channel-&gt;ReplicateSubobject(MyArray[i], *Bunch, *RepFlags);\n            sup |= MyArray[i]-&gt;ReplicateSubobjects(Channel, Bunch, RepFlags);\n        }\n    }\n    return sup;\n}\n</code></pre>"},{"location":"plugins/replicated-object/#move-object","title":"Move object","text":"<p>If you want to move an object between actors, then it's worth remembering how replication works in the Unreal Engine.</p> <p>Warning</p> <p>You can't just put a variable into another actor: its Outer will not change. To do this, you should use the Rename method.</p> <pre><code>AActor* anotherActor = ...;\nMyObjectPtr-&gt;Rename(nullptr, anotherActor);\n</code></pre> <p>It should be noted that the Rename function is quite slow and it will update on the client with a long delay.</p> <p>There may be bugs when using the variable on the client. So I recommend DuplicateObject().</p> <pre><code>AReplicatedActorExample* anotherActor = ...;\nUAdvancedReplicatedObject* copy = DuplicateObject(MyObjectPtr, anotherActor);\nanotherActor-&gt;MyObjectPtr = copy;\nMyObjectPtr-&gt;ConditionalBeginDestroy();\nMyObjectPtr = nullptr;\n</code></pre>"},{"location":"plugins/replicated-object/#tips-and-tricks","title":"Tips and tricks","text":"<ul> <li>Replication of large objects takes a long time. I recommend using direct TCP connection for large tasks like procedural generation or huge inventories in MMO RPG.</li> <li>Replication was tested only on the Dedicated Server. Listen server was not tested.</li> <li>Sometimes it is more advantageous to use RPC events to transfer bytes rather than replicating UObjects.</li> <li>Replicating arrays of UObjects takes a decent amount of time. Take into account that the inventory systems may take much longer to load than expected (more than 10ms).</li> <li>Remember that an object will live as long as its actor lives.</li> </ul> <p>Note</p> <p>I suggest deleting (ConditionalBeginDestroy()) objects before the actor is deleted to avoid problems with garbage collection and memory leaks.</p>"}]}